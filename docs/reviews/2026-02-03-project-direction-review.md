# プロジェクト方向性レビュー — 2026-02-03

## レビュー概要

footprint プロジェクトの現状を**6つの視点**から評価し、方向性に関する所見と提言をまとめる。

| 視点 | 評価 | 要約 |
|------|------|------|
| 1. プロダクト/ビジョン | 強い | 問題定義が明確。ただし「誰が最初に使うか」が未定 |
| 2. アーキテクチャ | 堅実 | 4層分離は適切。ただしL1→L0の依存方向に注意点あり |
| 3. 実装 | 初期段階 | L0コアの品質は高い。L1以降との距離が課題 |
| 4. ガバナンス/プロセス | 過剰気味 | 仕様の成熟度に対してプロセスが重い可能性あり |
| 5. リスク/優先度 | 要再検討 | OPEN が11件未解決。優先順位の絞り込みが必要 |
| 6. 実用化/採用 | 未着手 | 検証サイクル（spike→仕様確定→本実装）の確立が必要 |

---

## 1. プロダクト/ビジョン — 問題設定は強いが、解くべき最小問題が広い

### 良い点

- **「Information void を埋める」**という問題定義が明瞭で、ブレていない。
- **Non-goals（やらないこと）が明示的**。AI判断の排除、現在位置主張の排除、生存確率推定の排除は、プロダクトの暴走を防ぐ優れた歯止め。
- **"Last Known Good + Blank" というモデルは直感的**で、既存の位置情報サービス（Find My、Life360等）とは明確に差別化できている。
- 災害と平時の**二重用途（Dual Use）**設計は、「災害時だけのアプリは普及しない」という現実に対する正しい認識。

### 懸念と提言

**C-V1: 「誰の、どの場面の、どの痛み」が1つに絞れていない。**

現在の仕様は以下を同時に扱おうとしている：
- 災害時の捜索支援（救助者向け）
- 通信断/電池切れ時の最終位置記録（被災者側）
- BLEタグによるパッシブビーコン（IDEA-0001）
- BLEメッシュによるオフライン情報伝播（IDEA-0002）
- 暗号学的改ざん検知（IDEA-0003）
- 平時の登山/釣り利用（一般ユーザ）

これらはすべて有意義だが、**最初に証明すべき仮説**が定まっていない。

> **提言**: 「最初の1人のユーザが、最初の1回のシナリオで、footprintがなければ得られなかった価値を得る」場面を1つ定義する。それが**MVP（Minimum Viable Product）のスコープ**になる。

**C-V2: 「平時のハビット形成」が設計上は言及されるが、具体性がない。**

登山・釣りでの利用が Secondary use-case として挙がっているが、実際のユーザジャーニー（アプリを開く→何をする→何が残る→次回どう役立つ）が描かれていない。平時利用を本気で狙うなら、既存の登山アプリ（YAMAP、ヤマレコ等）との差分と共存戦略が必要。

> **提言**: 平時利用のペルソナとユーザストーリーを1本書く。「既存アプリでは解けない問題」を1つ特定する。

---

## 2. アーキテクチャ — 堅実だが、層間の「握り」がまだ弱い

### 良い点

- **L0〜L3の4層分離は適切**。特にL0（事実のみ、暗号なし）とL1（整合性証明）の分離は、RFC-0002の決定で正しく処理されている。
- **Append-only + canonical JSON**の設計は、hash chain/署名との将来的な統合を容易にする。
- `BTreeMap` を使ったキーの自動ソートは、正規化の要件を実装レベルで自然に満たしている。
- **外部依存ゼロ（Rust、no deps）**は、サプライチェーン攻撃リスクの排除と長期メンテナンス性の両面で優れた判断。

### 懸念と提言

**C-A1: L1（Share Envelope）のインターフェース定義がスキーマレベルで不在。**

`20_share_envelope_spec.md` は概念定義にとどまっており、L0の `trace.schema.json` に相当するL1のデータ契約が存在しない。L0の実装が進んだ今、L0→L1の接続点（L0イベントをL1エンベロープに包む際のフォーマット）を早めに定義しないと、L0側の設計にも手戻りが起きる可能性がある。

> **提言**: `docs/constitution/contracts/envelope.schema.json` の骨格を定義する。最低限 `{events: [...], hash_chain: [...], signature: ...}` のようなトップレベル構造だけでも。

**C-A2: L0のCLIインターフェース（stdin/stdout JSON）は、将来のモバイル組み込みと距離がある。**

現在のL0は `stdin → JSON parse → JSONL append → stdout` というCLI設計で、単体ツールとしては正しい。しかしAndroid/iOS組み込みを想定すると、FFI（Foreign Function Interface）やライブラリとしての呼び出しパスが必要になる。`lib.rs` の `run()` 関数は `OsString` イテレータを受け取る設計であり、ライブラリ利用には適さない。

> **提言**: 今すぐ変更する必要はないが、`lib.rs` に `run_with_input(store_path: &Path, json_input: &str) -> Result<SuccessOutput, CoreError>` のようなライブラリ向けエントリポイントを将来追加することを OPEN として記録しておく。

**C-A3: JSONL永続化はプロトタイプとしては適切だが、スケーラビリティの限界が明確。**

Append-only JSONLファイルは：
- 読み取り時にフルスキャンが必要（インデックスなし）
- 同時書き込みの制御なし（fsyncはあるがファイルロックなし）
- イベント数が増えると性能劣化が線形

これは「最初の1台の端末で数百〜数千イベント」の範囲では問題にならないが、設計文書にスケーラビリティの境界（JSONL卒業の条件）を明記しておくべき。

> **提言**: `10_core_fact_spec.md` に「JSONL永続化はプロトタイプ/初期段階の実装選択であり、イベント数がN件を超える場合の移行戦略は別途設計する」旨を OPEN として追記。

---

## 3. 実装 — L0の品質は高いが、次の一手が見えにくい

### 良い点

- **自作JSONパーサ/シリアライザの品質が高い**。UTF-8デコード、サロゲートペア処理、RFC 3339パース、負のエポック時刻など、エッジケースが丁寧に処理されている（`core/src/lib.rs`）。
- **正規化ルールが実装に埋め込まれている**（BTreeMapによるキーソート、数値のトレイリングゼロ除去、指数表記の正規化）。これはL1のhash chainで重要になる。
- **テストが仕様に紐づいている**（TST-0001〜0009）。ci.shの設計も「no-op green禁止」という規律が入っている。

### 懸念と提言

**C-I1: テストカバレッジが「正常系+基本異常系」に偏っている。**

`cli_integration.rs` を見ると、正常な保存と基本的なバリデーションエラーはテストされているが、以下のケースが不足している：
- 同一 traceId の重複投入時の挙動
- 超長文字列（数MB級のpayload）
- ストレージ満杯時の挙動
- ファイルシステムが読み取り専用の場合

> **提言**: TST に「境界条件・障害系」のカテゴリを追加。特に災害時利用を想定するなら、ストレージ不足/電池切れ直前の挙動テストは本質的に重要。

**C-I2: L0単体で「ユーザが触れるもの」が存在しない。**

現状、L0を体験するには `echo '{"traceId":...}' | cargo run` をターミナルで実行する必要がある。開発者以外は触れない。

> **提言**: 最小のWebUIまたはモバイルプロトタイプ（1画面：位置記録→一覧表示）を「見せられるもの」として検討。開発優先度は低いが、ステークホルダーへの説明や、ユーザフィードバック取得には不可欠。

---

## 4. ガバナンス/プロセス — 仕様の完成度に対して統治構造が重い

### 良い点

- **AGENTS.md の明快さ**。6つのエージェントの役割分担、SSOT（Single Source of Truth）の定義、ブロック時の前進ルール（Q/IF/RISK）が体系的に整理されている。
- **RFC/DECプロセス**が実際に運用されている（RFC-0001, 0002 → DEC-0001, 0002）。
- **「テストを弱めてはならない」ルール**（agent5の不可侵権限）は品質を守る優れた仕組み。

### 懸念と提言

**C-G1: 6エージェント体制は、現在の開発フェーズに対して重厚すぎる可能性がある。**

現在の実装は「L0のCLIが1つ動く」状態。この段階で6つの専門エージェント（Spec Lead / Backend / Android / Infra / QA / Integrator）が定義されているが、実質的に動いているのはAgent1（仕様）とAgent2（バックエンド）、Agent4（CI）程度。

Agent3（Android）、Agent5（QA）、Agent6（Integrator）は定義されているが、作業対象がほぼない。プロセスのオーバーヘッド（タスク定義 → 実行ログ → 成果物管理）が、実質的な進捗に対して重くなっているリスクがある。

> **提言**: 今のフェーズでは**2〜3ロール（Spec+Impl / QA / CI）**に簡素化し、モバイル実装が始まる段階でロールを分割する方が効率的。AGENTS.mdを変更する必要はないが、「アクティブなロール」を明示するセクションがあると実態に合う。

**C-G2: artifacts/ ディレクトリの管理コストが高い。**

`artifacts/inbox/tasks/`, `artifacts/runs/`, `artifacts/packs/` の3層構造は、タスクの入力→実行→出力を追跡するには理想的だが、実際の `.out.md` ファイルは形式的な報告に留まっている部分がある。タスク定義→実行ログの形式維持に時間を使うより、コードとSSOTドキュメントに集中した方が進捗速度は上がる。

> **提言**: artifacts/ は「人間が後で読み返して価値がある」もの（重要な設計判断の経緯、失敗からの学び）に限定し、定型的な実行ログは簡素化する。

---

## 5. リスク/優先度 — OPEN 11件が全部同じ重みで扱われている

### 良い点

- **懸念事項（C-001〜C-008）とリスク（RISK-PRIV-001）が体系的に整理**されている。
- **「停止が必要な危険領域」と「未解決の設計判断」が明確に分離**されている（RISK vs OPEN）。
- C-003（取りこぼしゼロの定義）のように、「不可能な領域」と「仕様化可能な領域」を冷静に切り分けている。

### 懸念と提言

**C-R1: OPEN 11件に優先順位がない。**

以下のOPENは、L1実装に着手する前に解決が必要（クリティカルパス上）：
- **OPEN-006**: relay と reveal の境界定義 → L1エンベロープの暗号化範囲に直結
- **OPEN-007**: 遭遇カプセルの暗号化鍵 → L1の鍵管理設計に直結

以下のOPENは、L2/L3実装まで遅延可能：
- OPEN-001, 003, 004, 005: オープン探索の粒度関連 → L2（Aggregation）の設計時に決定でよい
- OPEN-010: 権限救助者の定義 → L3（Platform）の設計時でよい

> **提言**: OPENに「Phase」列を追加し、「P-L1: L1実装前に必要」「P-L2: L2以降」「P-Ops: 運用設計時」のように分類する。

**C-R2: 「端末侵害」リスクの扱いが軽い。**

IDEA-0003のリスクとして「端末が乗っ取られると署名付きの嘘を作れる」と記載されているが、`80_risks.md` の懸念事項には入っていない。災害時に「偽の救助要請」「偽の目撃情報」が署名付きで流れるシナリオは、システムの信頼性を根幹から毀損する。

> **提言**: C-009（またはRISK-INTEG-001）として「端末侵害による署名付き虚偽情報」を `80_risks.md` に追加。「検証可能 ≠ 真実」という原則を、仕様レベルで明文化する。

**C-R3: BLE関連のIDEA（0001, 0002）はPoCが未実施のまま仕様検討に時間を投じている。**

IDEA-0001（BLEタグ）とIDEA-0002（BLEメッシュ）のリサーチドキュメントは合計23,000語以上。しかし「実機で動くか」の検証（PoC）がまだ行われていない。BLEのOS制約（特にiOSのバックグラウンドスキャン制限）は、仕様検討では解決できない実装上のハードブロッカーになり得る。

> **提言**: BLE関連は「仕様を書く前にPoCで嘘を潰す」方針が文書上は正しく記載されている。その方針を実行に移す段階。Android実機でのBLEスキャン/アドバタイズの最小検証を、仕様追加より先に行う。

---

## 6. 実用化/採用 — 「誰がいつ使えるか」の見通しがない

### 懸念と提言

**C-P1: 検証サイクルの形が定まっていない。**

現在のプロジェクトは仕様を精密に書く方向に進んでいるが、仕様の妥当性を実物で検証するサイクルが回っていない。

ただし「MVPを作ってリリースする」アプローチには注意が必要。MVPは作り直しが前提になることが多いが、**作り直しのコストは実際には非常に重い**。特にfootprintのようにデータ整合性・プライバシー・暗号学的正当性が本質のシステムでは、「とりあえず動くもの」の品質負債がmainに残るリスクが大きい。

**推奨: spike → 検証 → 固まればmainにマージ**

MVPではなく**spike（使い捨て検証）**で不確実性を潰し、設計が固まった部分だけをmainにマージする方針が、このプロジェクトの品質基準（暫定コード禁止、テスト弱体化禁止）と整合する。

| spike候補 | 検証対象 | 捨てるもの | mainに残すもの |
|-----------|---------|-----------|--------------|
| S1: L1 envelope round-trip | L0イベント→envelope包装→展開の往復 | spike用CLI/テストハーネス | envelope.schema.json + 正規化ルールの確定 |
| S2: BLE scan/advertise | Android実機でのBLEバックグラウンド動作 | spike用Androidプロジェクト | OS制約の事実整理（仕様へのフィードバック） |
| S3: hash chain構築 | canonical JSON → SHA-256 chain の実装検証 | spike用Rustバイナリ | hash chain仕様のDEC確定 |
| S4: 位置記録→地図表示 | L0データを地図上に表示する最小パス | spike用UI | UIが必要とするL0読み取りAPIの要件 |

> **提言**: 次のフェーズでは「何を作るか」ではなく**「何を検証するか」**を定義する。spike は feature branch で行い、学びを仕様（docs/constitution）に反映した上で、実装品質を満たす部分のみ main にマージする。spikeそのものはmainに入れない。

**C-P2: 競合/類似サービスとの差分分析がない。**

以下のサービスとの関係が未整理：
- **Apple Find My / Google Find My Device**: 位置共有の事実上の標準。footprintの「Last Known Good + Blank」はこれらとどう違うのか？
- **YAMAP / ヤマレコ**: 登山用途の位置記録。平時利用でこれらと競合/共存するのか？
- **ココヘリ / HITOCOCO**: 山岳遭難対応のBLEビーコンサービス。IDEA-0001と直接重複する。
- **災害用伝言板（171 / web171）**: 災害時の安否確認の既存インフラ。

> **提言**: `docs/backlog/` に競合分析を追加。「footprintでしか解けない問題」を1つ明確にする。

**C-P3: 法規制/制度面の検討が薄い。**

位置情報を扱うサービスには以下の法的考慮が必要：
- 個人情報保護法（日本）/ GDPR（EU展開を想定する場合）
- 電気通信事業法（BLEメッシュが通信に該当するか）
- 捜索救助における法的責任（「footprintの情報を信じて行動した結果の事故」の責任所在）

> **提言**: C-009（法規制リスク）として80_risks.mdに追加。少なくとも「個人情報保護法における位置情報の取り扱い」の基本方針を決める。

---

## 総合評価と推奨アクション

### footprint の強み（維持すべき方向）

1. **「事実 + 明示的な空白」というモデルは独自性がある。** 「わからない」を明示するシステムは稀であり、救助の意思決定品質を高める可能性がある。
2. **プライバシー設計（IF-SEARCH-001, IF-REVEAL-001）は本質的に正しい。** relay/reveal分離、サイレント閲覧禁止、通知送達保証は、類似サービスにない強い安全設計。
3. **仕様の記述品質が高い。** 懸念事項の構造化、不変条件の命名、OPEN/RISK/DECの分離は、チーム開発に耐えうるガバナンス。

### 推奨アクション（優先順序）

| 順位 | アクション | 根拠 |
|------|-----------|------|
| 1 | **OPENに優先度/フェーズを付与する** | 全部同時に解決しようとすると停滞する。L1前に必要なものを絞る |
| 2 | **OPEN-006, OPEN-007 を解決する** | L1実装のクリティカルパス上にある |
| 3 | **spike対象を1つ選び、feature branchで検証する** | 仕様だけでは潰せない不確実性を実物で確認する |
| 4 | **spikeの学びをdocs/constitutionに反映し、固まった部分をmainにマージ** | 検証→仕様確定→本実装の正規サイクルを回す |
| 5 | **競合分析を書く** | footprintの独自価値を関係者に説明できるようにする |

### 検証戦略について

MVPではなく**spike（使い捨て検証）**を検証手段とする。理由：

- MVPは作り直しが前提になることが多いが、**作り直しのコストは実際には非常に重い**
- footprintの品質基準（暫定コード禁止、テスト弱体化禁止、append-only）と、「とりあえず動くもの」は矛盾する
- spikeで不確実性を潰し、設計が固まった部分だけをmainに入れる方が、品質と速度の両立が可能

spikeはfeature branchで行い、mainにマージするのは仕様確定（DEC）と本実装品質のコードのみとする。

### 方向性そのものについて

プロジェクトの**方向性自体は正しい**と考える。災害時の情報空白を埋めるシステムに対するニーズは実在し、既存サービスでは十分にカバーされていない。特に「通信断を前提とした設計」と「プライバシーファーストの探索」は、技術的に挑戦的だが社会的価値が高い。

現在のリスクは**「完璧な仕様を目指して実装が進まない」**状態に陥ること。11件のOPENをすべて解決してからL1に着手するのではなく、**spikeで不確実性の高い箇所を先に検証し、その結果で仕様を固め、固まった範囲で本実装を進める**サイクルに移行すべきフェーズに来ている。

---

*レビュー日: 2026-02-03*
*対象ブランチ: claude/review-project-direction-YGycX*
*対象コミット: c164b4c*
