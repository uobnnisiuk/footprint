# Spike Backlog（検証項目一覧）

spike の対象候補と優先順位を管理する。spike 運用ルールは `AGENTS.md` §9.1 を参照。

---

## 1. OPEN の分類（フェーズ依存）

spike や本実装に着手する前に、OPEN をフェーズ別に整理し、今解くべきものと後回しにできるものを分ける。

### P-L1: L1（Share Envelope）実装前に解決が必要

| OPEN | テーマ | 理由 |
|------|--------|------|
| ~~OPEN-006~~ | ~~relay と reveal の境界定義~~ | **解決済み** → DEC-0003（公開ヘッダ + sealed payload に分離） |
| OPEN-007 | 遭遇カプセルの暗号化鍵は誰が持つか | L1 の鍵管理設計の前提 |
| OPEN-011 | 通知内容の最小セット | envelope に同梱する通知情報の範囲に影響 |

### P-L2: L2（Aggregation）設計時に解決

| OPEN | テーマ | 理由 |
|------|--------|------|
| OPEN-001 | オープン探索の「存在」の粒度 | 集約・フィルタの設計に依存。L0/L1 には影響しない |
| OPEN-003 | 密/疎の判定方法 | 集約ロジックの設計要素 |
| OPEN-004 | 確度（スコア）の表示上の意味 | UI/集約レイヤの責務 |
| OPEN-005 | オープン探索で履歴/パターンを返すか | 集約ロジックの責務 |
| OPEN-013 | T3=ON でオープン探索粒度が変わるか | OPEN-001 に依存 |

### P-L3: L3（Platform）/ 運用設計時に解決

| OPEN | テーマ | 理由 |
|------|--------|------|
| OPEN-008 | サイレント遭遇中継のスパム対策 | プラットフォームのレート制限・権限管理の設計 |
| OPEN-010 | 権限救助者の定義 | アクセス制御の設計。L0/L1 の仕様には影響しない |
| OPEN-012 | プラットフォーム不在/通信断時の T2 補完 | プラットフォーム層のフォールバック設計 |

---

## 2. Spike 候補一覧

### SPIKE-0001: L1 envelope round-trip

- **問い**: L0 の canonical event を L1 envelope に包み、展開して元に戻るか？フォーマット上の問題はないか？
- **不確実性の種類**: データフォーマットの往復
- **前提OPEN**: ~~OPEN-006（relay/reveal 境界）~~ → DEC-0003 で解決済み（公開ヘッダ + sealed payload）
- **検証手段**:
  1. L0 event 数件を canonical JSON で生成
  2. envelope 構造（events + metadata）に包む
  3. envelope から event を取り出し、canonical bytes が一致することを確認
  4. 不正な envelope（フィールド欠損、順序違い）で検証失敗を確認
- **成功判定**: round-trip で canonical bytes が一致。不正入力で検証失敗
- **mainに残すもの**: `envelope.schema.json` の骨格、正規化ルールの DEC
- **依存**: ~~OPEN-006~~ → DEC-0003 で解決済み。着手可能
- **優先度**: **高** — L1 本実装のクリティカルパス上

### SPIKE-0002: hash chain + 署名の構築・検証

- **問い**: canonical event 列から hash chain を構築し、改ざん検知が機能するか？Ed25519 署名は実用的か？
- **不確実性の種類**: 暗号学的操作の実装可能性
- **関連IDEA**: IDEA-0003
- **検証手段**:
  1. canonical event 列に対して `prev_hash` を含む hash chain を構築
  2. 任意の 1 event を改変し、検証で検出できることを確認
  3. 1 event を削除し、chain 切断を検出できることを確認
  4. Ed25519 で event（または chain segment）に署名し、検証を確認
  5. 鍵生成→署名→検証の round-trip を別環境（別バイナリ）で再現
- **成功判定**: 改変・欠落の検出が100%。署名検証が環境非依存で再現
- **mainに残すもの**: hash chain 仕様の DEC、署名アルゴリズム選定の DEC
- **依存**: SPIKE-0001 の envelope 構造が先にあると望ましいが、独立でも実行可
- **優先度**: **高** — L1 の integrity 設計に直結

### SPIKE-0003: BLE scan/advertise（Android 実機）

- **問い**: Android で BLE アドバタイズ/スキャンがバックグラウンドで安定動作するか？OS 制約はどこまでか？
- **不確実性の種類**: OS/HW 制約
- **関連IDEA**: IDEA-0001, IDEA-0002
- **検証手段**:
  1. Android 端末 2 台で BLE advertise + scan の最小アプリを作成
  2. フォアグラウンド/バックグラウンド/画面OFF でスキャン成功率を測定
  3. 距離別（1m/5m/10m/20m）で検出率と RSSI を記録
  4. 連続動作時の電池消費を測定（1時間単位）
  5. （可能なら）iOS 端末を追加して cross-platform 検出を確認
- **成功判定**: バックグラウンドで10m以内の検出率が80%以上、電池消費が許容範囲
- **mainに残すもの**: OS 制約の事実整理文書（docs/backlog/ に追記）、IDEA-0001/0002 の成立性判定
- **依存**: 実機が必要（エミュレータでは BLE 検証不可）
- **優先度**: **中** — IDEA-0001/0002 の成否を決定するが、L1 本実装とは独立

### SPIKE-0004: L0 読み取り + 地図表示

- **問い**: L0 の JSONL ストアからイベントを読み取り、地図上にプロットする最小パスは何か？
- **不確実性の種類**: L0 の読み取り API 要件の発見
- **検証手段**:
  1. L0 の events.jsonl を読み取り、JSON パースする最小コード
  2. location 付きイベントを地図ライブラリ（Leaflet 等）でプロット
  3. blank 状態のイベントを「空白区間」として可視化
  4. フィルタ（時間範囲、kind 別）の最小 UI
- **成功判定**: 手元のテストデータで「Last Known Good + Blank 区間」が地図上で視認できる
- **mainに残すもの**: L0 読み取り API の要件（読み取り用の関数シグネチャ案）
- **依存**: なし（L0 は既に実装済み）
- **優先度**: **中** — 仕様検証というより「見せられるもの」の獲得。ステークホルダー説明に有用

### SPIKE-0005: 通知送達保証（outbox crash recovery）

- **問い**: TST-0004（outbox crash recovery）の実装方式として、何が最小かつ十分か？
- **不確実性の種類**: OPEN の解決に実装知見が必要
- **関連RFC**: RFC-0002（notification queue persistence）
- **検証手段**:
  1. outbox を JSONL ファイルとして永続化
  2. enqueue → crash 模擬（プロセス kill）→ 再起動 → outbox 残存を確認
  3. enqueue → deliver → ack → outbox から削除の正常フロー確認
  4. WAL（Write-Ahead Log）方式との比較（必要に応じて）
- **成功判定**: crash 後に未送達通知が残存し、再起動後に再送可能
- **mainに残すもの**: outbox 永続化方式の DEC
- **依存**: OPEN-011（通知内容の最小セット）を IF で仮置きして着手可能
- **優先度**: **低〜中** — TST-0004 は受け入れ条件だが、L1 envelope より後でよい

---

## 3. 推奨着手順序

```
SPIKE-0001 (envelope round-trip)
    ↓ envelope 構造が固まる
SPIKE-0002 (hash chain + 署名)
    ↓ integrity 設計が固まる
    ↓ → ここで L1 本実装に着手可能
SPIKE-0003 (BLE 実機)        ← 0001/0002 と並行可能（独立）
SPIKE-0004 (地図表示)        ← 0001/0002 と並行可能（独立）
SPIKE-0005 (outbox recovery) ← L1 本実装中または後
```

SPIKE-0001 と SPIKE-0002 は直列（0001 の結果が 0002 の入力構造に影響する）。
SPIKE-0003 と SPIKE-0004 は他と独立なので、リソースがあれば並行実行可能。

---

## 4. spike を追加するとき

新しい spike を追加する場合、以下を記載する：
- **問い**（1〜2行）
- **不確実性の種類**（§9.1 の判断基準のどれに該当するか）
- **検証手段**（手順）
- **成功判定**
- **mainに残すもの**
- **依存**（他の spike や OPEN）
- **優先度**（高/中/低 + 理由）
